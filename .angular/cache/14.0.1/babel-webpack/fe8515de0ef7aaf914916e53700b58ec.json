{"ast":null,"code":"import _asyncToGenerator from \"/Users/henry.acuna/StudioProjects/opitech/prueba/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { __decorate } from \"tslib\";\nimport { Component, ViewChild } from '@angular/core';\nimport { MatTable } from '@angular/material/table';\nimport axios from 'axios';\nconst ELEMENT_DATA = [{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}];\n/**\n * @title Adding and removing data when using an array-based datasource.\n */\n\nlet AppComponents = class AppComponents {\n  constructor() {\n    this.displayedColumns = ['userId', 'id', 'title', 'completed'];\n    this.dataSource = [...ELEMENT_DATA]; // applyFilter(event: Event) {\n    //   const filterValue = (event.target as HTMLInputElement).value;\n    //   this.table.filter = filterValue.trim().toLowerCase();\n    // }\n  }\n\n  elementData() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        data\n      } = yield axios.get('https://jsonplaceholder.typicode.com/todos');\n      data.forEach(e => {\n        _this.dataSource.push(e);\n      });\n\n      _this.table.renderRows();\n    })();\n  }\n\n};\n\n__decorate([ViewChild(MatTable)], AppComponents.prototype, \"table\", void 0);\n\nAppComponents = __decorate([Component({\n  selector: 'a'\n})], AppComponents);\nexport { AppComponents };\nexport class AppComponent {\n  constructor(_httpClient) {\n    this._httpClient = _httpClient;\n    this.displayedColumns = ['created', 'state', 'number', 'title'];\n    this.data = [];\n    this.resultsLength = 0;\n    this.isLoadingResults = true;\n    this.isRateLimitReached = false;\n  }\n\n  ngAfterViewInit() {\n    this.exampleDatabase = new ExampleHttpDatabase(this._httpClient); // If the user changes the sort order, reset back to the first page.\n\n    this.sort.sortChange.subscribe(() => this.paginator.pageIndex = 0);\n    merge(this.sort.sortChange, this.paginator.page).pipe(startWith({}), switchMap(() => {\n      this.isLoadingResults = true;\n      return this.exampleDatabase.getRepoIssues(this.sort.active, this.sort.direction, this.paginator.pageIndex).pipe(catchError(() => observableOf(null)));\n    }), map(data => {\n      // Flip flag to show that loading has finished.\n      this.isLoadingResults = false;\n      this.isRateLimitReached = data === null;\n\n      if (data === null) {\n        return [];\n      } // Only refresh the result length if there is new data. In case of rate\n      // limit errors, we do not want to reset the paginator to zero, as that\n      // would prevent users from re-triggering requests.\n\n\n      this.resultsLength = data.total_count;\n      return data.items;\n    })).subscribe(data => this.data = data);\n  }\n\n}\n\n__decorate([ViewChild(MatPaginator)], AppComponent.prototype, \"paginator\", void 0);\n\n__decorate([ViewChild(MatSort)], AppComponent.prototype, \"sort\", void 0);\n/** An example database that the data source uses to retrieve data for the table. */\n\n\nexport class ExampleHttpDatabase {\n  constructor(_httpClient) {\n    this._httpClient = _httpClient;\n  }\n\n  getRepoIssues(sort, order, page) {\n    const href = 'https://api.github.com/search/issues';\n    const requestUrl = `${href}?q=repo:angular/components&sort=${sort}&order=${order}&page=${page + 1}`;\n    return this._httpClient.get(requestUrl);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Component","ViewChild","MatTable","axios","ELEMENT_DATA","AppComponents","constructor","elementData","data","get","forEach","e","dataSource","push","table","renderRows","__decorate","selector","AppComponent","_httpClient","ngAfterViewInit","exampleDatabase","ExampleHttpDatabase","sort","sortChange","subscribe","paginator","pageIndex","merge","page","pipe","startWith","switchMap","isLoadingResults","getRepoIssues","active","direction","catchError","observableOf","map","isRateLimitReached","resultsLength","total_count","items","MatPaginator","MatSort","order","href","requestUrl"],"sourceRoot":"","sources":["/Users/henry.acuna/StudioProjects/opitech/prueba/src/app/app.component.ts"],"sourcesContent":["import {Component, ViewChild} from '@angular/core';\nimport { MatTable, MatTableDataSource} from '@angular/material/table';\nimport axios from 'axios';\n\nexport interface PeriodicElement {\n  userId: number;\n  id: number;\n  title: string\n  completed: boolean;\n}\n\n\n\nconst ELEMENT_DATA: PeriodicElement[] = [\n  {\n    \"userId\": 1,\n    \"id\": 1,\n    \"title\": \"delectus aut autem\",\n    \"completed\": false\n  }\n];\n\n/**\n * @title Adding and removing data when using an array-based datasource.\n */\n @Component({\n  selector: 'a',\n})\nexport class AppComponents {\n  displayedColumns: string[] = ['userId', 'id', 'title', 'completed'];\n  dataSource = [...ELEMENT_DATA];\n\n  @ViewChild(MatTable) table!: MatTable<PeriodicElement>;\n  \n  async elementData() {\n    const { data } = await axios.get('https://jsonplaceholder.typicode.com/todos');\n    data.forEach((e: PeriodicElement) => {\n      this.dataSource.push(e);\n    });\n    this.table.renderRows();\n  }\n\n  // applyFilter(event: Event) {\n  //   const filterValue = (event.target as HTMLInputElement).value;\n  //   this.table.filter = filterValue.trim().toLowerCase();\n  // }\n}\n\n\nexport class AppComponent implements AfterViewInit {\n  displayedColumns: string[] = ['created', 'state', 'number', 'title'];\n  exampleDatabase: ExampleHttpDatabase | null;\n  data: GithubIssue[] = [];\n\n  resultsLength = 0;\n  isLoadingResults = true;\n  isRateLimitReached = false;\n\n  @ViewChild(MatPaginator) paginator: MatPaginator;\n  @ViewChild(MatSort) sort: MatSort;\n\n  constructor(private _httpClient: HttpClient) {}\n\n  ngAfterViewInit() {\n    this.exampleDatabase = new ExampleHttpDatabase(this._httpClient);\n\n    // If the user changes the sort order, reset back to the first page.\n    this.sort.sortChange.subscribe(() => (this.paginator.pageIndex = 0));\n\n    merge(this.sort.sortChange, this.paginator.page)\n      .pipe(\n        startWith({}),\n        switchMap(() => {\n          this.isLoadingResults = true;\n          return this.exampleDatabase!.getRepoIssues(\n            this.sort.active,\n            this.sort.direction,\n            this.paginator.pageIndex,\n          ).pipe(catchError(() => observableOf(null)));\n        }),\n        map(data => {\n          // Flip flag to show that loading has finished.\n          this.isLoadingResults = false;\n          this.isRateLimitReached = data === null;\n\n          if (data === null) {\n            return [];\n          }\n\n          // Only refresh the result length if there is new data. In case of rate\n          // limit errors, we do not want to reset the paginator to zero, as that\n          // would prevent users from re-triggering requests.\n          this.resultsLength = data.total_count;\n          return data.items;\n        }),\n      )\n      .subscribe(data => (this.data = data));\n  }\n}\n\nexport interface GithubApi {\n  items: GithubIssue[];\n  total_count: number;\n}\n\nexport interface GithubIssue {\n  created_at: string;\n  number: string;\n  state: string;\n  title: string;\n}\n\n/** An example database that the data source uses to retrieve data for the table. */\nexport class ExampleHttpDatabase {\n  constructor(private _httpClient: HttpClient) {}\n\n  getRepoIssues(sort: string, order: SortDirection, page: number): Observable<GithubApi> {\n    const href = 'https://api.github.com/search/issues';\n    const requestUrl = `${href}?q=repo:angular/components&sort=${sort}&order=${order}&page=${\n      page + 1\n    }`;\n\n    return this._httpClient.get<GithubApi>(requestUrl);\n  }\n}"]},"metadata":{},"sourceType":"module"}